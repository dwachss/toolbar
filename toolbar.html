<!DOCTYPE html>
<html>
<head>
<title>toolbar testing</title>
<script src=toolbar.js></script>
<style>
	body {
		display: flex;
		flex-direction: column;
		margin: 0;
		height: 95vh;
	}
	textarea {
		flex: auto;
	}
	#hebrewkeyboard button {
		font-family: serif;
	}
	[role=toolbar]{
		counter-reset: buttoncounter;
		margin: 2px 10px;
	}
	[role=toolbar] button {
		font-size: 18px;
		height: 1.3em;
		position: relative;
		padding: 1px 4px 14px;
		min-width: 1.5em;
		vertical-align: bottom;
		counter-increment: buttoncounter;
	}
	[role=toolbar] button::before {
	    content: attr(name);
		position: relative;
		bottom: 0.1em;
	}
	[role=toolbar].active button::after {
		content: counter(buttoncounter, upper-alpha);
		position: absolute;
		opacity: 30%;
		z-index: 1;
		bottom: -1.2em;
		right: 0.25em;
		font-size: 20px;
		font-family: sans-serif;
		font-style: normal;
		color: black;
		font-weight: bold;
	}
	[role=toolbar] button.highlight, [role=toolbar] button[aria-pressed] {
		background: linear-gradient(ThreeDHighlight, ThreeDHighlight, ButtonFace);
		border: 2px inset buttonface;
		border-radius: 4px;
	}
	button.reverse\~words::before {
		content: 'â†”ï¸';
	}
	button.pig\~latin::before {
		content: 'ğŸ–';
		bottom: 0.4em
	}
	button.a , button.×§ , button.×– {
		margin-left: 0.5em;
	}
	button.z , button.×©{
		margin-left: 1em;
	}
</style>
</head>
<body>
<div id=hebrewkeyboard style=display:none ></div>
<div id=keyboard style=display:none ></div>
<div id=toolbar><button name='nothing'></button></div>
<textarea></textarea>
<input />
<script>

function toggle (el){
	if (window.getComputedStyle(el).display == 'none'){
		el.style.display = 'block';
	}else{
		el.style.display = 'none';
	}
}
function reversewords (text){
	return text.split('\n').map(function(s){
		return s.split(/\s+/).reverse().join(' ');
	}).join('\n');
};

function piglatin (text){
	return text.replace(/([bcdfghjklmnpqrstvwxyz]*)([aeiou])([a-z]*)/ig,
	 (_, p1, p2, p3) => p2 + p3 + ( p1 ? p1 + 'ay' : 'way'))
}


function run (command){
	if (command == 'reverse') {
		this.value = reversewords(this.value);
	}else if (command == 'anslatetray'){
		this.value = piglatin(this.value);
	}else if (command == 'nothing'){
		console.log('Nothing happens');
	}else if (command == 'kbd'){
		toggle(document.querySelector('#keyboard'));
	}else if (command == 'hkbd'){
		toggle(document.querySelector('#hebrewkeyboard'));
	}else{
		this.value = this.value + command;
	}
	document.querySelector('textarea').focus();
}

function type (command){
	const before = this.value.substring(0,this.selectionStart);
	const after = this.value.substring(this.selectionEnd);
	this.value = before + command + after;
	this.setSelectionRange (before.length + command.length, before.length + command.length);
	document.querySelector('textarea').focus();
}

const t = new Toolbar (document.querySelector('#toolbar'), document.querySelector('textarea'), run, 'toolbar');
t.button('reverse~words', 'reverse', 'Reverse Words in Selection');
t.button('Ping', ' ping!');
t.button('nothing', 'nothing');
t.button('pig~latin', 'anslatetray', 'Translate to Pig Latin');
t.button(' foo');
t.togglebutton('âŒ¨ï¸', 'kbd', 'Toggle Virtual Keyboard');
t.togglebutton('âŒ¨ï¸~he', 'hkbd', 'Toggle Virtual Hebrew Keyboard');

const k = new Toolbar(document.querySelector('#keyboard'), document.querySelector('textarea'), type, 'English keyboard');
k.buttons('qwertyiop'.split('').map( x => [x] ));
k.element('<br>');
k.buttons('asdfghjkl;'.split('').map( x => [x] ));
k.element('<br>');
k.buttons('zxcvbnm,.'.split('').map( x => [x] ));


// getting the Hebrew diacritics to display correctly and be editable in Notepad++ is painful. 
const hk = new Toolbar (document.querySelector('#hebrewkeyboard'), document.querySelector('textarea'), type, 'Hebrew Keyboard');
const nikudnames = '×©×©Ö°××•Ö¸× ×—Ö²×˜Ö·×£Ö¾×¡Ö¶×’Ö¼×•Ö¹×œ ×—Ö²×˜Ö·×£Ö¾×¤Ö·Ö¼×ªÖ·×— ×—Ö²×˜Ö·×£Ö¾×§Ö¸×Ö¸×¥ ×—Ö´×™×¨Ö´×™×§ ×¦Öµ×™×¨Öµ×™ ×¡Ö¶×’Ö¼×•Ö¹×œ ×¤Ö¼Ö·×ªÖ·×— ×§Ö¸×Ö·×¥ SinÖ¾dot ShinÖ¾dot ×—×•Ö¹×œÖ¸× ×“Ö¼Ö¸×’Öµ×©× ×§Ö»×‘Ö¼×•Ö¼×¥ ×§Ö¸×Ö·×¥Ö¾×§Ö¸×˜Ö¸×Ÿ'.split(' ');
hk.buttons('×©Ö° ×©Ö± ×©Ö² ×©Ö³ ×©Ö´ ×©Öµ ×©Ö¶ ×©Ö· ×©Ö¸ ×©×‚ ×©× ×•Ö¹ ×©Ö¼ ×©Ö» ×©×‡'.split(' ').map( (x, i) => [x, x[1], nikudnames[i]])); // can't seem to get the unicode dotted-circle to display consistently; use a shin instead
hk.element('<br>');
const taamnames = '×Ö»× Ö·Ö¼Ö£×— ×–Ö·×¨Ö°×§Ö¸×Ö® ×¡Ö¶×’Ö¼×•Ö¹×œÖ’ ×¨Ö°×‘Ö´Ö—×™×¢ ×Ö·×”Ö°×¤Ö·Ö¼Ö¤×š ×¤Ö·Ö¼×©Ö°××˜Ö¸×Ö™ ×–Ö¸×§Öµ×£Ö¾×§Ö¸×˜Ö¸Ö”×Ÿ ×–Ö¸×§Öµ×£Ö¾×’Ö¸Ö¼×“Ö•×•Ö¹×œ ×Öµ×¨Ö°×›Ö¸Ö¥× ×˜Ö´×¤Ö°Ö¼×—Ö¸Ö–× ×Ö¶×ªÖ°× Ö·×—Ö°×ªÖ¸Ö¼Ö‘× ×¤Ö¸Ö¼×–ÖµÖ¡×¨ ×ªÖ°Ö¼×œÖ´×™×©Ö¸×Ö¾×§Ö°×˜Ö·× Ö¸Ö¼×”Ö© ×ªÖ°Ö¼Ö ×œÖ´×™×©Ö¸×Ö¾×’Ö°×“×•Ö¹×œÖ¸×” ×§Ö·×“Ö°×Ö¸Ö¨× ×•Ö°×Ö·×–Ö°×œÖ¸Öœ× ×Ö·×–Ö°×œÖ¸×Ö¾×’ÖµÖ¼Öœ×¨Öµ×©× ×’ÖµÖ¼×¨Ö°×©Ö·×Ö×™Ö´× ×“' + 
 'Ö·Ö¼×¨Ö°×’Ö¸Ö¼Ö§× ×ªÖ°Ö¼×‘Ö´Ö›×™×¨ ×™Ö°Öš×ªÖ´×™×‘ ×¤Ö¼Ö°×¡Ö´×™×§×€ ×¡×•Ö¹×£Ö¾×¤Ö¸Ö¼×¡Ö½×•Ö¼×§×ƒ ×©Ö·××œÖ°×©Ö¶×Ö“×œÖ¶×ª ×Öµ×¨Ö°×›Ö¸×Ö¾×›Ö°Ö¼×¤×•Ö¼×œÖ¸Ö¦×” ×™Öµ×¨Ö¶×—Ö¾×‘Ö¶Ö¼×ŸÖ¾×™×•Ö¹×Öª×•Ö¹ ×§Ö·×¨Ö°× Öµ×™Ö¾×¤Ö¸×¨Ö¸ÖŸ×” ×’ÖµÖ¼×¨Öµ×©×Ö¾×Ö»×§Ö°×“Ö¸Ö¼×Ö ××ª× ×—Ö¾×”×¤×•×šÖ¢ ×¢×•Ö¹×œÖ¶×”Ö« ×¢Ö´×œÖ¼×•Ö¼×™Ö¬ ×“×—×™Ö­ ×¦Ö´× Ö¼×•Ö¹×¨Ö´×ªÖ˜';
const taamim = taamnames.replace(/[ ×§×¨××˜×•×Ÿ××¤×©×“×’×›×¢×™×—×œ×š×£×–×¡×‘×”× ××¦×ª×¥×©Ö°×©Ö±×©Ö²×©Ö³×©Ö´×©Öµ×©Ö¶×©Ö·×©Ö¸×©×‚×©××•Ö¹×©Ö¼×©Ö»Ö¾×¡Ö½]/g, '').split(''); // strip everything that isn't a taam
hk.buttons(taamim.map ( (x,i) => ['×©' + x, x, taamnames.split(' ')[i]] ));
hk.element('<br>');
hk.buttons([['â‚ª'], ['×©Ö½','×©Ö½'[1], '××ª×’'], ['×©×„', '×©×„'[1], 'Upper Dot'], ['×©×…','×©×…×…'[1],'Lower Dot'], ['×†'], ['Ö¾'], ['×©Ö¿', '×©Ö¿Ö¿'[1], '×¨×¤×”'], ['×´'], ['×³'], ['×²'], ['×±'], ['×°']]);
hk.element('<br>');hk.buttons('×§×¨××˜×•×Ÿ××¤'.split('').map( x => [x] ));
hk.element('<br>');
hk.buttons('×©×“×’×›×¢×™×—×œ×š×£'.split('').map( x => [x] ));
hk.element('<br>');
hk.buttons('×–×¡×‘×”× ××¦×ª×¥'.split('').map( x => [x] ));


</script>
</body>
</html>